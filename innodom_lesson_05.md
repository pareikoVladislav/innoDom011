# **Продолжаем знакомиться с коллекциями. Множества, словари.**

**Множества:**

**Множества** - неиндексированная структура данных, в которой элементы           
хранятся в случайном порядке и не могут повторятся. Если при создании           
множества элементы в нём повторяются, то повторные элементы из множества             
удаляются. Благодаря этим особенностям, операции с множествами выполняются             
значительно быстрее и с меньшей производительностью.


**Множества** могут быть **изменяемыми** (`set()`) и **неизменяемыми** (`frozenset()`)

Синтаксис создания множеств:

```python
my_set = set()
my_set_1 = {1, 4, 2}

my_frozenset = frozenset((1, 4, 6, 2, 4))
```

При создании множеств мы можем хранить в них ТОЛЬКО уникальные значения, неизменяемые           

Любой изменяемый тип данных уникальным быть **не может**           

Внутренняя реализация set базируется на **хэшировании** и **таблицах хэшей**           
(hash tables). Вот как это работает:

* Когда мы создаём пустой **set** с помощью **my_set = set()**, Python            
создает пустую **хэш-таблицу**.

* При добавлении элемента в **set**, Python вычисляет хэш этого элемента            
(с использованием метода **hash**) и определяет, в какой "корзине" хранить этот            
элемент в **хэш-таблице**. Если несколько элементов имеют одинаковый хэш, они хранятся                 
в одной корзине и решаются коллизии.

* При поиске элемента в **set**, Python вычисляет хэш этого элемента и быстро определяет,          
в какой корзине искать. Затем происходит сравнение элемента с элементами в корзине,           
и если элемент найден, возвращается результат.

* При удалении элемента из **set**, Python снова вычисляет хэш элемента и находит корзину,                
в которой он находится. Затем элемент удаляется из корзины.

* Это позволяет **set** обеспечивать быстрое добавление, удаление и проверку на            
наличие элементов за счет хорошей амортизированной временной сложности.


**frozenset** - это неизменяемая версия **set**, что означает, что после создания         
вы не можете изменить его содержимое. Внутренняя реализация **frozenset** схожа       
с **set**, но с одним основным отличием:


* Поскольку **frozenset** является неизменяемым, он может использовать хэширование          
всех своих элементов при создании, и этот хэш сохраняется. Это делает **frozenset**          
хэшируемым и, следовательно, может быть использован в качестве ключа в словарях **dict**.           

* Так как **frozenset** неизменяем, он не подвержен операциям добавления             
или удаления элементов, что делает его полезным в ситуациях, когда            
вам нужно иметь неизменяемый набор элементов.

---

Очень интересно, но ничего непонятно, думаю. Давайте разбираться!           

### **Хэширование (Hashing):**
**Хэширование** - это процесс преобразования входных данных (например, строк,             
чисел, объектов) в **фиксированный размерный хэш-код (хэш)**. Целью хэширования             
является уникальное представление данных с фиксированным размером, что              
позволяет **быстро** выполнить операции **поиска**, **добавления** и **удаления**              
элементов в структуре данных, основанной на **хэш-таблице**.


### **Хэш-таблица (Hash Table):**
**Хэш-таблица** - это структура данных, которая использует хэширование для            
**эффективного хранения** и **быстрого доступа** к данным. Основная идея заключается в          
том, что каждый элемент хранится в корзине (бакете) на основе его хэш-кода.            


**Корзины** представляют собой массивы или списки, и элементы с одинаковым хэш-кодом            
помещаются в одну и ту же корзину. Затем для поиска, добавления или удаления            
элемента необходимо вычислить его **хэш-код**, найти соответствующую корзину            
и выполнить операцию в этой корзине.

**Преимущества** хэш-таблиц заключаются в том, что операции добавления, поиска и                 
удаления могут быть выполнены за постоянное время в среднем случае (**O(1)**),             
если **хэш-функция** хорошо распределяет элементы по корзинам.


### **Коллизия (Collision):**
**Коллизия** происходит, когда два разных элемента имеют одинаковый хэш-код и,            
следовательно, должны быть помещены в одну и ту же корзину. Коллизии            
неизбежны, так как хэш-коды ограничены по размеру, а количество данных,             
которые нужно хранить, может быть гораздо больше.

---

Так как наши множества могут хранить в себе только **неизменяемые типы данных**,                
мы можем хранить в нашем изменяемом множестве **set()** неизменяемый           
**frozenset()**, но наоборот - нет:

Благодаря множествам, можно выполнять математические операции со структурами             
данных (**объединение**, **пересечение**, **вычитание** и др) быстро и просто.

---

![img_14.png](img_14.png)

---

## **Операции между множествами:**


**Объединение множеств (|):**

При объединении создаётся **ещё одно множество**, которое содержит все            
элементы, входящие в первоначальные два (без дубликатов).

```python
set_1 = {"hello", 3, 3, 1, 9, "vlad"}
set_2 = {9, 10, 22, 4, 5, 6, "andrey"}

print(set_1 | set_2)
```

**Пересечение множеств (&):**

При пересечении создаётся новое множество, содержащее все элементы,            
**общие для обоих** (без дубликатов).

```python
set_1 = {"hello", 2, 3, 4}
set_2 = {"hello", 3, 4, 5, 6}
print(set_1 & set_2)
```

**Вычитание множеств (-):**

При использовании разности создаётся новое множество, включающее элементы,            
которые есть в **левом** множестве, но не входят в **правое** множество.                    

```python
set_1 = {"hello", 2, 3, "qwerty", 4}
set_2 = {3, 4, 5, "hello", 6, 7}

print(set_2 - set_1)
```

**Симметричное вычитание множеств (^):**

Создаётся новый объект, включающий все элементы, за исключением тех,          
которые есть в обоих множествах.

```python
set_1 = {1, "Vadim", 3, 6, 4, 5}
set_2 = {3, 5, "hello", 6, 7, 8}

print(set_1 ^ set_2)
```

Другими словами Питон проходится по каждому элементу в каждом из множеств,            
И записывает в новое множество только те элементы, которые есть исключительно           
в этом множестве.

---

## **Методы множеств:**

У множеств достаточно много разных методов:

* `.isdisjoint(other)` - возвращает **True**, если множество и            
**other** **не имеют** общих значений

```python
set_1 = {1, 2, 3, 10, 4, 5}
set_2 = {5, 6, 7, 8, 9, 10}

print(set_1.isdisjoint(set_2))
```

* `.issubset(other)` - вернёт **True**, если множество является           
подмножеством для **other**

```python
set_1 = {10, "Vova"}
set_2 = {1, 2, 3, "a", "b", 7, 5, 9}

print(set_1.issubset(set_2))
```

* `issuperset(other)` - вернёт **True**, если множество является           
надмножеством для **other**

```python
set_1 = {"b", 7, 5}
set_2 = {1, 2, 3, "a", "b", 7, 5, 9}

print(set_1.issuperset(set_2))
```

* `union(other_1, other_2)` - объединяет несколько множеств. **Аналогично (|)**        

```python
female_students = {"Anna", "Nicka", "Valeria", "Kristin", "Maria"}
male_students = {"David", "Mike", "Nicka", "Adrey", "John", "Kristin", "Sumit"}


hight_school_students = set.union(female_students, male_students)

print(hight_school_students)

# или же 
print(female_students.union(male_students))
```

* `intersection(other)` - вернёт пересечение множеств. **Аналогично (&)**            

```python
set_1 = {"hello", 2, 3, 4}
set_2 = {"hello", 3, 4, 5, 6}
set_3 = set.intersection(set_1, set_2)
print(set_3)
```

* `difference(other)` - вернёт множетво с элементами, не принадлежащими                  
ни одному из other. **Аналогично (-)**

```python
set_1 = {"hello", 2, 3, "qwerty", 4}
set_2 = {3, 4, 5, "hello", 6, 7}
print(set_1.difference(set_2))
```

* `copy()` - создаёт копию множества

```python
sentitive_data = {12312353, 3454542, 443234, 6897655, 23456, 987654}

copy_of_data = sentitive_data.copy()
print(copy_of_data)
print(copy_of_data is sentitive_data)
```

Приведённые выше методы **не работают** с **frozenset**, кортежами и списками.             

Так же есть методы, которые не возвращают нам новое множество, как было выше,            
а **изменяют наш текущий set** ( так как наш **set** - **изменяемый тип данных** ):            


* `add()` - добавляет новый элемент в множество

```python
set_1 = {1, 2, 3, 4}

set_1.add("l")

print(set_1)
```

* `remove()` - удаляет элемент из множества. **KeyError**, если элемента             
во множестве нет.

```python
set_1 = {5, 6, 7, 8, 9}

set_1.remove(7)

print(set_1)
```

* `discard()` - аналог метода **remove**, только если элемента не найдено - ничего.             

```python
set_1.discard("vlad")
```

* `pop()` - удаляет и возвращает элемент из множества. Так как элементы                
во множестве неупорядоченные, нельзя предугодать какой элемент будет удалён.               

```python
set_1 = {"a", "b", 1, 2, frozenset((7, 8, 9))}

a = set_1.pop()

print(set_1)
print(a)
```
* `clear()` - очищает множество

```python
set_1.clear()

print(set_1)
```

---

1) Создайте два множества **set1** и **set2**. Если они имеют хотя бы один             
общий элемент, выведите сообщение "Есть общие элементы", иначе            
выведите "Нет общих элементов".

2) Создайте два множества **a** и **b**, содержащих несколько элементов.              
Если множество a является подмножеством множества b, выведите             
"a - подмножество b", иначе выведите "a не является подмножеством b".

3) Создайте множество **fruits** с несколькими названиями фруктов. Попросите             
пользователя ввести название фрукта и удалите его из множества.              
Если фрукт был успешно удален, выведите "Фрукт удален из              
множества", иначе "Фрукт не найден".

4) Создайте два множества odd_numbers и even_numbers, содержащих нечетные              
и четные числа от 1 до 10 соответственно. Попросите пользователя ввести             
число и выведите "Четное" или "Нечетное" в зависимости от того,          
в каком множестве оно находится.

5) Создайте два множества set_a и set_b, содержащих различные элементы.              
Если хотя бы один из них пуст, объедините их в одно множество              
и выведите его содержимое.


---

# **Словари**

**Словари** - это неупорядоченная структура данных, в которой у             
каждого элемента есть своя ассоциация (ключ). Данные представляются             
в виде элементов ключ:значение.

Ключи могут быть **ТОЛЬКО** неизменяемыми типами данных, значения могут            
быть любыми типами данных.

```python
# new_dict = {} # создаст пустой словарь.
my_list = [1, 2, 3, 4, 5, 6]
students = {
    "name": "Vlad",
    "surname": "Lebovski",
    "age": 25,
    "sex": "male",
    "education": "engineer",
    5: "test"
}
```

Мы можем обращаться к ключам наших словарей, получая по ним значения:

```python
students["name"]
```

Если мы попытаемся таким образом обратиться к ключу, которого нет - получим          
KeyError:

```python
# student["work"]
```
Для этого у нас есть метод `.get()`

Мы так же можем создавать новые ключи и давать им значения:

```python
student["work"] = "Amazon company" # создаст новый ключ work и даст ему значение Amazon company
```

```python
del student[5] # удалит наш ключ 5 и его значение
```

Как ещё можно создавать словари?

```python
dict_1 = dict(name="Vlad",
              age=32,
              sex="binary person",
              job="driver",
              asd="asdasd")

print(dict_1)
```
```python
dict_2 = dict([("pet", "dog"), ("name", "fluffy"), ("age", 3), ("hungry", False)])

print(dict_2)
```

```python
keys_list = ("name", "age", "job")
values_list = ["David", 45, "QA"]

dict_3 = dict(zip(keys_list, values_list))
```

```python
# задача с собеседования
my_new_dict = {
    1: "father",
    False: "mother",
    True: "son",
}
```

**Вложенные словари:**

Мы так же можем создавать **вложенные словари** для создания более          
сложных структур. Частенько можно встретить в **JSON** данных,           
которые **backend** подготавливает для **frontend**.

```python
employee = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "current work": {
        "id": 1,
        "position": "QA engineer",
        "work experience": "3 years",
        "work qualification": "QA"
    }
}
```

```python
employee_1 = {
    "id": 1,
    "name": "Valeria",
    "surname": "Black",
    "age": 21,
    "education": "hight",
    "work_experience": [
        {
            "id": 1,
            "position": "QA engineer",
            "work experience": "1 years",
            "work qualification": "senior"
        },
        {
            "id": 2,
            "position": "software developer",
            "work experience": "1.3 years",
            "work qualification": "middle"
        },
        {
            "id": 3,
            "position": "QA engineer",
            "work experience": "5 years",
            "work qualification": "junior"
        }
    ],
}
```

---

## **Методы словарей**

* `keys()`: Метод **keys()** возвращает представление всех ключей в словаре.              

```python
employee.keys()
```

* `values()` возвращает представление всех значений в словаре.        

```python
employee.values()
```

* `items()` возвращает представление всех пар "ключ-значение" в           
словаре в виде кортежей.

```python
employee.items()
```

* `get()`: позволяет получить значение по ключу с возможностью           
указать значение по умолчанию, если ключ не существует.

```python
employee.get("rabota", "NOT FOUND")
```

* `setdefault()`: позволяет получить значение по ключу, а если ключ          
не существует, то установить значение по умолчанию и вернуть его.              

```python
employee.setdefault("pet", True)
```

---

# **Заключение:**

### **Общие моменты множеств и словарей:**

* **Общие черты словарей и множеств:**
    * **Оба являются коллекциями в Python.**
    * **Позволяют хранить и организовывать данные.**
* **Основные различия между словарями и множествами:**
    * Словари хранят пары "ключ-значение", в то время как множества          
    хранят только уникальные элементы без порядка.
    * Доступ к значениям в словаре осуществляется по ключу, в           
    множестве - по самому элементу.
    * Словари могут содержать разные типы данных в качестве ключей и          
    значений, в то время как множества могут содержать только хешируемые          
    объекты(неизменяемые типы данных).
    * Множества поддерживают операции над множествами, такие как объединение,           
    пересечение и разность, в то время как словари таких операций не поддерживают


### **Когда что использовать:**

* **Словари:**
    * Необходимо хранить и получать значения по уникальным ключам.
    * Нужно отображение между ключами и значениями.
    * Требуется изменяемость значений

* **Множества:**
    * Необходимо хранить только уникальные элементы без порядка.
    * Требуется выполнение операций над множествами, таких как объединение,           
    пересечение или разность.
    * Нужно проверить принадлежность элемента к множеству.


---

1) Создайте словарь **student_grades**, где ключами будут имена студентов,            
а значениями - их оценки (целые числа). Запросите у пользователя имя            
студента и выведите его оценку. Если студент не найден в словаре,           
выведите "Студент не найден".

2) Создайте словарь **inventory** с товарами и их количеством в магазине.             
Попросите пользователя ввести название товара и проверьте, есть ли этот               
товар в словаре. Если товар не найден, установите для этого товара значение          
4 по умолчанию.

3) Создайте два словаря **english_words** и **spanish_words** с переводами английских            
и испанских слов. Попросите пользователя ввести слово на английском и             
выведите его перевод на испанский. Если слово не найдено, выведите           
"Перевод не найден".

```python
spanish_words = {
    "Бабочка": "Mariposa",
    "Обучение": "Formación",
    "Ресторан": "Restaurante",
    "Программирование": "Programación",
}

english_words = {
    "Butterfly": "Бабочка",
    "Training": "Обучение",
    "Restaurant": "Ресторан",
    "Programming": "Программирование",
}
```

4) Создайте словарь **phone_book** с именами контактов и их номерами телефонов.            
Попросите пользователя ввести имя контакта и выведите его номер.            
Если контакт не найден, спросите пользователя, хочет ли он создать новый контакт.            
Если да - создайте новый ключ с номером телефона, который пользователь должен          
будет ввести. Если нет - прекратить работу.

```python
book_contact = {
    "Andrey": "+1234568789",
    "Irina": "+793545613254",
    "Nikita": "+995557003215",
    "Alex": "789456123121",
}
```
