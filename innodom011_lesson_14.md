# **Staticmethod, Classmethod. Inheritance in Python**

## **Staticmethod**

Наши с вами класс и его будущие инстансы (объекты по этому классу)                                
немного отличаются по логике выполнения, и имеют при реализации                                 
свою самостоятельную среду окружения, стоит об этом помнить.                               

```python
class StaticTest:
    x = 1

test_1 = StaticTest()

print(f"Via class instance - {test_1.x}")
print(f"Via class - {StaticTest.x}")
```

При создании объекта по классу мы получим отдельную сущность, созданную по                          
определённому шаблону. В этом объекте будет своя переменная `x`, которая не                          
будет зависеть от нашего `x` в самом классе.                             

Так же если мы теперь обновим этот атрибут на уровне класса - мы изменим                             
именно этот атрибут на уровне самого класса.                                 

```python
StaticTest.x = 3
print(f"Via class instance - {test_1.x}")
print(f"Via class - {StaticTest.x}")
```

Если в дальнейшем по этому классу будем создавать другие инстансы - они переменят                              
обновлённое значение `x` для себя.

```python
new_test = StaticTest()
new_test.x
```

Таким образом мы убедились, что атрибуты класса и атрибуты объекта класса                             
совершенно различны.                                    


**Что такое статические методы?**                                

**Статические методы** - это методы, которые привязаны к классу, а не к конкретному                             
экземпляру этого класса. Они являются частью класса, а не его объекта, и                           
могут вызываться непосредственно из самого класса, без создания экземпляра.                             

**Статические методы** обычно используются для выполнения операций, не зависящих                           
от конкретных атрибутов экземпляров класса.                             


**Определение статических методов**                              

**Статический метод** определяется внутри класса с использованием ключевого                           
слова `@staticmethod` перед определением метода. Он не принимает обязательного                            
параметра `self`, как это делают обычные методы класса. Вместо `self`                                
статический метод может принимать другие параметры, необходимые для                             
выполнения операции.                                  

В отличие от динамических методов классов, **статические методы не могут**                               
**взаимодействовать с атрибутами экземпляра класса**, так как они не имеют                                
доступа к `self`. Они могут взаимодействовать только с атрибутами класса,                               
которые общие для всех экземпляров.                              

**Синтаксис статических методов**                      

```python
class MyClass:
    some_int = 15

    def __init__(self, val1, val2):
        self.val1 = val1
        self.val2 = val2

    @staticmethod
    def sqr_norm(a, b):
        return a*a + b*b
```

Статические методы по факту являются обычными функциями, которые "вшиты"                           
в контекст определённого класса.                        
Они работают независимо от нашего класса, или объекта класса и могут быть                                
использованы внутри наших динамических методов \ методов класса.                                

Так же такие методы могут вызываться как через сам класс, так и через его                                  
экземпляр.                                          

```python
my_class = MyClass(5, 5)
my_class.sqr_norm(5, 5)

MyClass.sqr_norm(10, 20)
```

**Где применяются статические методы?**                           

Использование статических методов для общих операций, не зависящих                            
от экземпляра класса                                        
**Статические методы** полезны в ситуациях, когда вы хотите выполнить операции,                             
которые не зависят от конкретных атрибутов экземпляров класса, но связаны                                
с классом в целом. Например, статические методы могут использоваться для                                 
**математических вычислений**, **обработки данных** или **вспомогательных функций**.                                   

**Преимущества и недостатки статических методов**                        

**Преимущества**
1) `Улучшение читаемости кода:`                           
**Статические методы** могут быть вызваны непосредственно из класса, что делает                        
код более читаемым и понятным, поскольку они показывают, что метод не                            
зависит от конкретных экземпляров.                                  

2) `Возможность вызова метода без создания объекта:`                                  
**Статические методы** позволяют вызывать операции класса **без необходимости**                               
создавать экземпляр класса.                                          

**Недостатки**                                
1) `Ограниченный доступ к атрибутам экземпляра:`                                   
Статические методы не имеют доступа к атрибутам экземпляра класса, что                                 
может быть ограничением в некоторых случаях.                                        

2) `Они не могут быть переопределены в подклассах:`                                         
Статические методы не могут быть переопределены в подклассах, что                                    
может ограничивать их гибкость.                                     


**Tasks**                                      

1) **Создание класса для работы с геометрическими фигурами**                                  
Вычесть площадь разных фигур, используя статические методы                                   

2) **Реализация управления настройками фигур**                                     
дополнить класс Geometry новыми методами (статичными и динамичными), чтобы                       
управлять настройками фигур                                  

3) Разработка работы с датами и временем                                         
дополнить класс Geometry динамическими и статичными методами так, чтобы                                  
управлять операциями с датами и временем, когда была вычислена                                   
площать определённой фигуры                                 

---

## **Classmethod**

**Что такое методы класса?**                         

**Методы класса** - это функции, определенные внутри класса, которые                             
имеют доступ к атрибутам и методам самого класса, а не к конкретным                               
экземплярам этого класса. Эти методы могут быть вызваны на уровне класса,                               
а не только на уровне экземпляра, и они обычно выполняют операции,                                
связанные с классом в целом, а не с конкретными объектами.                               


**Определение методов класса**                  
**Методы класса** определяются внутри класса и обозначаются декоратором `@classmethod`.                             
Они принимают первым параметром ссылку на класс (часто обозначают его как `cls`),                           
что позволяет им работать с атрибутами класса и вызывать другие методы класса.                             

В отличие от динамических методов классов (**методов экземпляра**), методы класса                       
**не требуют создания экземпляра класса** для вызова. Они могут вызываться напрямую                       
на самом классе.                                  


```python
class SuperClass:
    some_static_argument = "Hello from Class"

    @classmethod
    def get_class_argument(cls):
        return cls.some_static_argument

a = SuperClass()

a.get_class_argument()
a.some_static_argument
SuperClass.get_class_argument()
SuperClass.some_static_argument
```

**Где применяются методы класса?**                              

Использование методов класса для операций, связанных с классом в целом,                             
но не зависящих от конкретного экземпляра                           

Методы класса часто используются для выполнения операций, которые связаны с                             
классом в целом, а не с конкретными объектами класса. Они могут выполнять                                 
операции на атрибутах класса и обрабатывать данные, которые общие                                
для всех экземпляров класса.                             


**Преимущества и недостатки методов класса**                         


**Преимущества**                        

1) `Возможность доступа к атрибутам класса:`                                  
Методы класса имеют доступ к атрибутам класса и могут изменять его состояние,                                 
делая их мощным инструментом для управления данными, общими для                            
всех экземпляров.                                  

2) `Возможность вызова метода на уровне класса:`                                        
Методы класса могут быть вызваны на самом классе без необходимости создания                                     
экземпляра, что упрощает доступ к функциональности класса.                                      


**Недостатки**                           

1) `Более сложный синтаксис:` Синтаксис методов класса сложнее, чем у                               
статических методов, что может потребовать больше кода для их определения.                               


Используя методы класса, вы можете обеспечить логическую организацию методов,                            
которые имеют отношение к классу, но не требуют доступа к конкретным                               
экземплярам. Это может повысить читаемость кода и упростить его                              
обслуживание. Однако это не предоставляет дополнительных рамок или контекста                             
для метода, так как он все равно имеет доступ к глобальным                                
атрибутам и методам класса.                                    


**Так же, какое есть преимущество в работе с методами класса:**                                    

Дело в том, что наши классы позволяют в себе хранить только один метод `__init__()`                              
То есть для одного класса только один инициализатор.                          

**В чём может быть проблема?**                              

Иногда наши классы могут быть определены(инициализированы) по разному.                              
Может быть `n` способов вполне себе валидных способов создания объекта                               
класса. И для всех этих возможных способов **ВСЕГО ОДИН** инициализатор                                       
может не подойти - потому что это будет один инициализатор с кучей параметров,                               
большая часть из которых будет установлена по умолчанию.                             

Такие инициализаторы становятся перегруженными, непонятными, их становится крайне                             
трудно читать и понимать.                       

Помимо этого у нашего инициализатора нет имени. Когда мы создаём объект по классу                               
мы просто прописываем название класса и просто передаём параметры в                                   
скобках. Иногда такого синтаксиса недостаточно, чтобы писать "самодокументированный"                                
код (код выразительный, который понятен просто по названию метода, в котором он                                  
содержится, выражает намерения.)                                  

В таких случаях мы можем прибегнуть к нашим методам класса, которые позволят нам                             
обыграть это дело.                             

Плюс тут в том, что у методов класса есть имя, и оно может быть вполне описательным                               
Благодаря этому, создавая новый объект класса, используя такой метод, мы                              
можем писать более красивый, понятный код, ведь когда мы вызываем такой метод                          
нам сразу понятен смысл создания такого объекта класса.                              

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return f"{self.day}-{self.month}-{self.year}"
```

Допустим мы хотим дать возможность альтернативного использования класса, где                            
пользователь указывает своё день рождения конкретно в 2000-ом году.                           

```python
class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year

    def display(self):
        return f"{self.day}-{self.month}-{self.year}"

    @classmethod
    def millenium(cls, day, month):
        return cls(day, month, 2000)
```

**Tasks**                            

Создать класс `Person`, который принимает имя и фамилию в качестве аргументов                          
при конструировании.                        

**Класс должен поддерживать атрибуты:**                         

* `first_name`, возвращающий имя                       
* `last_name`, возвращающий фамилию                       
* `full_name`, возвращающий имя и фамилию                          
* `initials`, возвращающий инициалы                    

Класс должен приводить переданные имя и фамилию в форму при которой имя                                            
и фамилия начинаются с заглавной буквы, а все остальные буквы в нижнем регистре                                  
(поскольку вызывающий код может передавать такие строки как "JOHN",                                   
'jOHN', 'sMiTh' и т.д.)                                   

Так же учесть, что пользователь может передать только имя.                     

---

# **Inheritance**                        

**Наследование** - это механизм в объектно-ориентированных языках программирования,                            
таких как **Python**, который позволяет создавать новый класс на основе                            
существующего класса. Новый класс наследует атрибуты (переменные) и методы                           
(функции) из родительского класса и может дополнять, изменять                           
или переопределять их.                           

Подкласс может добавлять собственные атрибуты и методы, а также переопределять                         
методы родительского класса.                               


Когда производный класс наследует свойства и методы от базового класса, он может                                
использовать их как свои собственные, добавлять новые или изменять существующие.                               
Это позволяет существенно упростить разработку и поддержку кода, так как                                 
можно переиспользовать уже существующую функциональность.                                        

```python
class Animal:
    def __init__(self):
        self.paws = 4
        self.tail = True
        self.ears = 2
        self.wool = True

class Cat(Animal):
    def __init__(self, name, age):
        super().__init__()
        self.name = name
        self.age = age

    def say_mew(self):
        print(f"Your pet {self.name} say 'Meaw'!")


    def __str__(self):
        return f"""
        Cat's name: {self.name}
        Cat's age: {self.age}
        Cat's paws: {self.paws}
        Cat with tail? - {self.tail}
        Cat's ears: {self.ears}
        Cat have wool? - {self.wool}
        """
```

Метод `super()` в **Python** используется для вызова методов родительского класса                               
из дочернего класса. Он позволяет получить доступ к родительским методам и их                           
поведению. Этот метод полезен для выполнения специфических действий в дочерних                                
классах, при этом сохраняя и используя функциональность, предоставленную                              
родительским классом.                                 

Использование `super()` особенно полезно в тех случаях, когда дочерний класс                                
переопределяет методы родительского класса и нужно выполнить какую-то логику                              
из родительского метода в дополнение к собственной логике дочернего класса.                               

Метод `super()` не ограничивается только статическими атрибутами класса. Он                           
предназначен для вызова методов родительского класса и обращения как к                           
статическим, так и к динамическим атрибутам класса-родителя.                              

По сути, `super()` предоставляет доступ к всем атрибутам и методам родительского                             
класса, включая как статические, так и динамические атрибуты, внутренние и                           
внешние методы, и другие элементы класса.                               

Когда вызывается `super()`, это означает, что дочерний класс может получить                          
доступ к поведению и атрибутам родительского класса и использовать их, а                              
также расширить или изменить это поведение по своему усмотрению.                              


```python
class Shape:
    def __init__(self):
        print("Shape created")
    
    def draw(self):
        print("Drawing a shape")

    def area(self):
        print("Calc area")

    def perimeter(self):
        print("Calc perimeter")


class Triangle(Shape):
    def __init__(self, base, height):
        Shape.__init__(self)
        self.base = base
        self.height = height
        
    def draw(self):
        print("Drawing a triangle")

    def area(self):
        return 0.5 * self.base * self.height

    def perimeter(self):
        return self.base + 2 * (self.height ** 2) ** 0.5

class Rectangle(Shape):
    def __init__(self, width, height):
        Shape.__init__(self)
        self.width = width
        self.height = height
        
    def draw(self):
        print("Drawing rectangle")

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

triangle = Triangle(4, 5)
rectangle = Rectangle(3, 6)

print(triangle.draw())
print(f"Area: {triangle.area()}, Perimeter: {triangle.perimeter()}")

print(rectangle.draw())
print(f"Area: {rectangle.area()}, Perimeter: {rectangle.perimeter()}")
```



**Иерархия классов и класс-потомок**                            

Иерархия классов - это структура, в которой классы организованы в                             
иерархическом порядке наследования. В этой иерархии классы делятся на                               
родительские и дочерние классы. Класс-потомок (дочерний класс) наследует                            
от класса-родителя (базового класса).                                     

**Как определяется наследование?**                                   

Для определения наследования в Python вы создаете новый класс, указывая имя                                
родительского класса внутри определения нового класса. Новый класс                              
автоматически наследует атрибуты и методы родительского класса.                                

**Преимущества и недостатки наследования**                               


**Преимущества**                           

1) `Повторное использование кода:`                                  
Наследование позволяет повторно использовать атрибуты и методы из                              
родительского класса в дочернем классе, что способствует                                  
уменьшению дублирования кода.                                

2) `Организация классов в иерархии:`                                
Наследование позволяет создавать иерархию классов, где классы могут                                 
быть логически сгруппированы и упорядочены.                                        

**Недостатки**                                 

1) `Сложность иерархии:`                                 
Слишком глубокая и сложная иерархия наследования может стать сложной                               
для понимания и обслуживания.                                

2) `Проблемы с переопределением:`                                             
Переопределение методов из родительского класса в дочернем классе может                                 
привести к трудностям, если не учтены все детали.                                    

